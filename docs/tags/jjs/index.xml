<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jjs on My personal blog</title>
    <link>/tags/jjs.html</link>
    <description>Recent content in jjs on My personal blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Jun 2015 15:48:54 +0200</lastBuildDate><atom:link href="/tags/jjs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>debugging a java application with an interactive shell</title>
      <link>/2015/06/28/debugging-a-java-application-with-an-interactive-shell.html</link>
      <pubDate>Sun, 28 Jun 2015 15:48:54 +0200</pubDate>
      
      <guid>/2015/06/28/debugging-a-java-application-with-an-interactive-shell.html</guid>
      <description>Since a while ago, the JVM has an embedded Javascript engine within. Since Java 8 (I think) this engine got extended through an interactive shell. So now you can start an interactive Javascript shell within your JVM. Knowing that, I wondered why nobody tried to use this feature, to do some debugging. So I tried.
First I had to find the coresponding class of the jjs tool. I&amp;rsquo;m not sure I found the right one, but I did find a Shell class within the nashorn.</description>
    </item>
    
    <item>
      <title>add jar to the classpath at runtime in jjs (the hacky way)</title>
      <link>/2015/06/27/add-jar-to-the-classpath-at-runtime-in-jjs.html</link>
      <pubDate>Sat, 27 Jun 2015 14:22:54 +0200</pubDate>
      
      <guid>/2015/06/27/add-jar-to-the-classpath-at-runtime-in-jjs.html</guid>
      <description>Normally, the JVM does not allow extending the classpath during runtime. But due to the demand, people found ways around that restriction. To bring one of the work-around to jjs I wrote the following javascript function.
function addUrlToClasspath(pathName){ var/*java.net.URLClassLoader*/ sysloader = /*(java.net.URLClassLoader) */ java.lang.ClassLoader.getSystemClassLoader(); var/*java.lang.Class*/ sysclass = java.net.URLClassLoader.class; var ClassArray = Java.type(&amp;#34;java.lang.Class[]&amp;#34;); var parameters = new ClassArray(1); parameters[0]= java.net.URL.class; var/*java.lang.reflect.Method*/ method = sysclass.getDeclaredMethod(&amp;#34;addURL&amp;#34;, parameters); method.setAccessible(true); var ObjectArray = Java.type(&amp;#34;java.lang.Object[]&amp;#34;); var array = new ObjectArray(1); var/*java.</description>
    </item>
    
    <item>
      <title>doing objects in jjs</title>
      <link>/2015/06/13/doing-objects-in-jjs.html</link>
      <pubDate>Sat, 13 Jun 2015 08:12:55 +0200</pubDate>
      
      <guid>/2015/06/13/doing-objects-in-jjs.html</guid>
      <description>Instantiating a Java Object in jjs is pretty straight forward, at least it can be.
var string = new java.lang.String(&amp;#34;hello world&amp;#34;); //alternative var stringClass = Java.type(&amp;#34;java.lang.String&amp;#34;); var string = new stringClass(&amp;#34;hello world&amp;#34;); This was so easy that I instantly continued trying Arrays.
//doing it javascript style var arr=[]; arr[0]=&amp;#34;hello&amp;#34;; arr[1]=&amp;#34;world&amp;#34;; java.lang.String.join(&amp;#34; &amp;#34;,arr); //doing it java style var stringClass=java.lang.String.class; var arr2==java.lang.reflect.Array.newInstance(StringClass,2); You could argue that using the java style initialization doesn&amp;rsquo;t add anything and complicates stuff overly.</description>
    </item>
    
    <item>
      <title>read the content of a file in one line in jjs</title>
      <link>/2015/06/12/read-the-content-of-a-file-in-one-line-in-jjs.html</link>
      <pubDate>Fri, 12 Jun 2015 12:32:25 +0200</pubDate>
      
      <guid>/2015/06/12/read-the-content-of-a-file-in-one-line-in-jjs.html</guid>
      <description>The task is pretty simple, read the content of text file as one-liner. Here is what I came up with.
var filename = &amp;#34;engine.log&amp;#34;; var content = new java.lang.String( java.nio.file.Files.readAllBytes( java.nio.file.Paths.get(filename) ) ); </description>
    </item>
    
    <item>
      <title>print something to the console in jjs</title>
      <link>/2015/06/11/print-something-to-the-console-in-jjs.html</link>
      <pubDate>Thu, 11 Jun 2015 11:12:45 +0200</pubDate>
      
      <guid>/2015/06/11/print-something-to-the-console-in-jjs.html</guid>
      <description>Once I got jjs running I started with some pretty simple stuff. To print something to the console I found the following ways.
//javascript style print(&amp;#34;hello world&amp;#34;); // don&amp;#39;t forget the parentheses here, otherwise jjs wont like you //java style var System = Java.type(&amp;#39;java.lang.System&amp;#39;); System.out.println(&amp;#34;hello world&amp;#34;); //of course there is an error out too System.err.println(&amp;#34;hello world&amp;#34;); Don&amp;rsquo;t forget to declare System as Variable, otherwise it will fail.
nashorn&amp;gt; System.out.println(&amp;#34;hello world&amp;#34;); script error: ReferenceError: &amp;#34;System&amp;#34; is not defined in &amp;lt;STDIN&amp;gt; at line number 1 </description>
    </item>
    
    <item>
      <title>using jjs under osx</title>
      <link>/2015/06/06/jjs-under-osx.html</link>
      <pubDate>Sat, 06 Jun 2015 18:22:03 +0200</pubDate>
      
      <guid>/2015/06/06/jjs-under-osx.html</guid>
      <description>Recently I wanted to try the new java8 integration javascipt shell. So I installed the Oracle JDK on my mac, opened a terminal and got the following result:
localhost:~ jens$ jjs -bash: jjs: command not found After some googling around I found that the jjs execution is part of the packaged jdk but not really there. After some time I found that it is installed under the name jrunscript. So now I only had to alias jjs to jrunscript and I could start.</description>
    </item>
    
  </channel>
</rss>
